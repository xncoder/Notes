* Org Mode
** Outline and Writing                                               :hjiang:
*** insert heading
 M-Enter will insert a heading in current position
         and the newly heading is same with privious heading
*** promote heading
 M-Left  will promote the heading by one level
*** demote heading 
 M-Right will demote the heading by one level
*** promote entire subtree
 M-Shift-Left will promote an entire subtree
*** demote entire subtree
 M-Shift-Right will demote an entire subtree
** Plain List
** unordered plain list
   - first subitem
   - second subiten
     + another item
     + some thing else

(- or +) then press M-Enter, org mode will add a (- or +) automatically
** ordered plain list
   1. this is the first item
   2. this is the second item
   3. hsh
   4. this is the trird item
(1.) then press M-Enter, org mode will add a (2.) automatically
** add a checkbox
   - [ ] this is fiest checkbox
   - [ ] this is second checkbox
   - [ ] this is third checkbox
start the line with - [ ], toggle the check box using C-c C-c
** hyper links                                           :hyper_links_in_org:
** simple urls
http://www.baidu.com
** simple file path
file:/etc/file.pdf
** plain-text tables
 | name   | sex | age | number |
 |--------+-----+-----+--------|
 | hjiang | man | 23  | 234    |
 |        |     |     |        |
 |        |     |     |        |
 |        |     |     |        |
** tags                                                        :org_set_
* Gdb usage
** compiling source file to debug            :symbolic:dubugging:information:
   gcc -g test.c -o test
   g++ -g test.cpp -o test

** debug in a gui mode
   gdb -tui
   arrow and page(down/up) key will srcoll the source window
   
   >list test.c:4 will bring up the file test.c on line 4

   >r or >run will run the program
   >r arg1 arg2 will run the program with the arguments

** break point
   >b main        :break at the main function
   >b 5           :break at the 5th line
   >b test.c:5    :break at line 5 of test.c

   >i b           :(info b) get the infomation of the break point

*** disable a break
   >disable 1     :disable the first break
   >clear main    :clear the break "main"


*** stepping
    >n             :move you to the next statement
    >s             :step into a function
    >c             :continue excution
    >[Enter]       :repeat last command you input

*** examing varible
   >disp i               :display the variable i, and display it every time you stop code
   >undisp i             :undisplay
   >info display
   >print i              :one-off display
   >printf "format" i    :format display

** misc stuff

*** backtrace
    >backtrace            :(bt) show current function call stack

*** addtional stepping
    >finish               :exit current excution function and return to the calling function
    >stepi                :step a single assembly instuction
    >advance loc          :coutinue to this temp loc

*** jump to arbitrary section
    >jump 3               :jump to line 3

*** set variables and values
    >set (i=20)
    >set variable i = 40

*** hardware watch point
    >watch var

* Emacs+Git => Magit
** magit-status : to display information about the current Git repository 
** p,n : Move between sections using ~p~ and ~n~.
   [tab]: expand or collapse the section at point.
   staging:         ~s~ to stage the changes you have made to specific file.
   unstaging:       (~u~) commands operate on the change at point
   commit:          And then of course you want to commit your changes.  Type ~c~.
   common commit:   We want to create a "normal" commit, which is done by typing ~c~ again
   real commit:     Write a message and then type ~C-c C-c~ to actually create the commit.
   push:            ~P~ to bring up the push popup
                    ~p~ to push to a branch with the same name as the local branch onto the
                    remote configured as the push-remote
* unix/linux
** append one file to another file's tail
   cat file1.txt >> file2.txt
** something about using git
*** initialize a empty Git repository :
   git init

   The previous command will init a '.Git' directory in
   current directory. the structure of this directory is
   like:
   -----------------------------------------------------
   HEAD
   config
   description
   hooks/
   info/
   objects/
   refs/
   -----------------------------------------------------
   Tips: config is the only file that we can change

*** git config
   config is done at 3 stages:
   1. system(--system)
   2. user(--global)
   3. project

   Example1:
   git config user.email hjiang@sse.com.cn

   The previous command will append two lines to "config" file:
   [user]
	email = hjiang@sse.com.cn


   Example2:
   git config --global user.name "hjiang"
   git config --global user.ID "0715039"

   the previous commands will add three lines to .gitconfig in $HOME
   [user]
       name = hjiang
       ID = 0715039

*** git arch
   view git in three level
   [level-1] User Working Dir
   [level-2] Stage(index)
   [level-3] Repository

   2-step process:
   lev-1 ---> lev-2 : git add
   lev-2 ---> lev-3 : git commit

   lev-3 ---> lev-2 : git reset --
   lev-2 ---> lev-1 : git checkout --

   1-step process:
   lev1-->lev2-->lev3 : git commit -a
   lev3-->lev2-->lev1 : git checkout HEAD --

   2.4 git updating repository
   git add filename
   git commit -m "some kind of message"

   2.5 git checkout

   a. to the latest version:
      git checkout -- filename

   b. to any previous version:
      git log
      the previous command will get commit infomation:

   commit 34ccee5100c00b2668f9f785c000e8ae75c9d73a
   Author: hjiang <hjiang@sse.com.cn>
   Date:   Mon Nov 6 11:10:53 2017 +0800

       add a line in File1.txt

   commit 25f65bf8abd9190509dbdd19ee97593318fe1c43
   Author: hjiang <hjiang@sse.com.cn>
   Date:   Mon Nov 6 11:02:28 2017 +0800

       First line was written at file1.txt

   commit a11b757a56870313c98e86d476416158f0cd2925
   Author: hjiang <hjiang@sse.com.cn>
   Date:   Mon Nov 6 10:59:00 2017 +0800

       This is a test of git commit
   
** introduce to make file:
   /src : contain source file
          main.cpp, extra.cpp, other.cpp
   /bin : contain dest binary file

   makefile:
   bin/myprogm: src/extra.cpp src/main.cpp src/other.cpp
       g++ $^ -o $@

   then in command line:
   make
   or make -B

** split a text file in to a word list
   tr -s '[[:punct:][:space:]]' '\n' < testfile.txt
** find command
*** find a string in a directory[the directory have multi files]
    grep -rnw '/path/to/somewhere/' -e 'pattern'
*** find a file bigger or smaller than a given size 
    find . -type f -size +6096c [find files bigger than 6096bytes]
   find . -type f -size -6096c [find files smaller than 6096bytes]


          -size n[cwbkMG]
              File uses n units of space, rounding up.  The following suffixes
              can be used:

              `b'    for  512-byte blocks (this is the default if no suffix is
                     used)

              `c'    for bytes

              `w'    for two-byte words

              `k'    for Kilobytes (units of 1024 bytes)

              `M'    for Megabytes (units of 1048576 bytes)

              `G'    for Gigabytes (units of 1073741824 bytes)

              The size does not count  indirect  blocks,  but  it  does  count
              blocks in sparse files that are not actually allocated.  Bear in
              mind that the `%k' and `%b' format specifiers of -printf  handle
              sparse   files  differently.   The  `b'  suffix  always  denotes
              512-byte blocks and never 1 Kilobyte blocks, which is  different
              to  the  behaviour of -ls.  The + and - prefixes signify greater
              than and less than, as usual, but bear in mind that the size  is
              rounded  up to the next unit (so a 1-byte file is not matched by
*** linux 在一个文件夹中的所有文件中查找一个字符串:
  grep -rnw '/path/to/somewhere/' -e 'pattern'
  r: recursive
  n: number of the line
  w: match the whole word

  search the files which have .c or .h extensions:
  grep --include=\*.{c,h} -rnw 'path/to/somewhere' -e 'pattern' 

  exclude searching all the files ending with .o extension:
  grep --exclude=\*.o -rnw 'path/to/somewhere' -e 'pattern' 

  --exclude-dir, --include-dir

** sed command
   essential command: s for substitution
   sed 's/one/ONE' file.txt
   s: substitution command
   /../../ : delemeter
   one : Regular expression Pattern Search Pattern
   ONE : Replacement string

   using & as the matched string:

   extened regular expression:
   echo "123 abc" | sed -r 's/[0-9]+/& &/'
   -r: stand for extented regular expression

   using \1 to keep part of the pattern:
   sed 's/\([a-z]*\).*/\1/' Basic.sh , will keep the first word of this line
   sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/' Basic.sh , will switch two word
   sed 's/\([a-z][a-z]*\) \([a-z][a-z]*\)/\2 \1/' file.txt , ensure a word has least one letter

   sed -r 's/([a-z]+) ([a-z]+)/\2 \1/' file.txt , using extended regular expression
   sed -r 's/([a-z]+) \1/\1/' file.txt , \1 can occur in the pattern regular expression
   sed -nr '/([a-z]+) \1/p' file.txt , will detect duplicated words
   sed -r 's/(.)(.)(.)/\3\2\1/' file.txt, reverse first three cha on a line

   Sed Pattern Flag, specify what happens when a match is found
   sed 's/[^ ]*/(&)/' test.txt, this parenthesis around the first word
   sed 's/[^ ][^ ]*/(&)/g' test.txt, this parenthesis around all the word

   /1, /2 etc. Specifying witch occurrence
   sed -r 's/([a-zA-Z]*) ([a-zA-Z]*)/\1 /' test.txt, keep the first word on line and leave the next
   sed -r 's/([a-zA-Z]*) //1' test.txt, same as privious line
   sed -r 's/[a-zA-Z]* /DELETED /1g' test.txt
   sed 's/[a-zA-Z]* /DELETED /2g' test.txt

   sed -e 's/a/A/' -e 's/b/B' test.txt , multiple command with -e

** history command
     !! : repeat last command
     !ssh : recall last command start with ssh
     history : see the list of excuted command
     !13 : recall command with index is 13

* passwd
  OA and OutNet:
  Name:hjiang
  Passwd: Jiang0715039

  AST591:198.2.11.1
  AST592:198.2.156.1
  AST593:198.2.56.1
  AST594:198.2.186.1
  DEV03:172.23.1.101

  OA信息管理系统:
  User:hjiang
  Passwd:hjiang

  远程报单数据库地址: 10.112.3.249
  ezstep_jiangheng
  sa
  sa

* OpenVms
** EzEI extract 广播数据使用说明：
  0）进入 bin目录，重置环境变量
  . ./setenv 

  1）导出oc二进制数据。 -set后参数表示set号， -tp参数是主题名， -startno表示主题起始号， -endno是结束号， -fipath表示导出二进制文件路径
  ./showall -bcdt -set 109 -tp 1 -startno 1 -endno 100 -fipath ../data/output/109-1.txt

  2、使用showbcdt解析出的可视化数据,  -s为showall导出文件位置， -conf 为配置文件位置， -o为数据文件位置（可显示文件）
  ./showbcdt -bcdt -s ../data/output/109-1.txt -conf ../conf/tools/showbcdt/atp-oc-bcst.txt -o ../data/output/atp-oc.txt


  备注：
  1）目的是截取一段区间。如果是endno大于实际的数据的最大数据号的，则最终截取实际数量的。
  例如oc只有[1, 100], 则如果-startno=1， -endno=1000,实际获取的数据范围是：[1, 100]

  2) 解析可视化数据是实际数据，不包含set,type，以及序号。 但是能够保证，数据是有序递增。具体数据列表是以上oc的数据范围。


  COPY UEXE:AM63.EXE AST591"NGTS_15 SHANGHAI"::TOFF$EXE: /FTP /L
  COPY UEXE:MAHBM001.EXE AST591"NGTS_15 SHANGHAI"::TOFF$EXE: /FTP /L

** 常用查询命令:
  订单簿: mcr tol$exe:showotw -ord -set 109 -time *,*
  rdrlog: mcr tol$exe:showwp -rdr -set 109 -time *,*
  广播内存: mcr tol$exe:showwp  -brc -set 109 -p EZEI0 -tp 19 -range *,*
  订阅内存: mcr tol$exe:showall -hhbm -subinfo

** OPENVMS下DEBUG程序:
  本地主机上: set display/create/trans=tcpip/node=本地主机ip
  开发主机上: 
  COPY U3$:[ATP04.DEV.SIR.33070]MSHDPT001.C   USRC /L 
  COPY U3$:[ATP04.DEV.SIR.33070]MSHDPT002.C   USRC /L
  COPY U3$:[ATP04.DEV.SIR.33070]SHOWOTW.C     USRC /L
  COPY U3$:[ATP04.DEV.SIR.33070]MSHCCR002.C   USRC /L

  perl utools:debug.pl
  设置debug窗口的IP地址:SET DISPLAY/CREATE/TRANS=TCPIP/NODE=196.131.3.78

** 修改系统文件后CONV：
  CONV /FDL=TOFF$FDL:FTBIZSTK USER_FTBIZSTK_FILE USER_FTBIZSTK_FILE /STAT

  @BACK01$:[AIR.SCRIPT]AUTO_RESTORE.COM BACK01$:[TOFF29.DATA.POST_BACKUP.POST_BACKUP_A040400_CUR_20070312] A

** Upgrade Back Env:
     @BACK01$:[AIR.SCRIPT]AUTO_RESTORE.COM BACK01$:[TOFF20.DATA.POST_BACKUP.POST_BACKUP_20070312] A
     @BACK01$:[AIR.SCRIPT]AUTO_RESTORE.COM BACK01$:[TOFF78.DATA.POST_BACKUP.POST_BACKUP_A040600_CUR_20070312] A

** dcl脚本调试
     set verify
     define toff$verify "ON"

** openvms delete file and directory:
      a. delete a file
      delete xxx.dat;1 /l

      b. delete all files in current dir:
      delete *.*.* /l

      c. delet a dir and all files in sub dir:
      set def xxxx
      dir
      delete [...]*.*.* /tree /l

** run a openvms file with process name:

      run /detatched/process=hibertrig hibertrig
      ana/sys
      show process hibertrig

      stop hibertrig

** OpenVms Copy a Locked file:
  conv /share file new_file /stat

** 查看或在所有的虚拟桌面切换: Win + Tab
      创建新的虚拟桌面: Win + Ctrl + D
      关闭当前虚拟桌面: Win + Ctrl + F4
      切换虚拟桌面: Win + Ctrl + L/F x
      虚拟桌面顺序:
      a. 编程环境
      b. 文档编辑
      c. 文档，书籍，资料查看

** Cmder 常用命令:
      Ctrl + Tab  : Swicth Between Tabs
      Ctrl + T    : Create a New Tab

** OpenVMS 管道
      pipe install list/global | sea sys$input 85_85

      the DCL pipe command under OpenVms:

      PIPE command-sequence [separator command-sequece]

      PIPE常用功能:
      a. 多命令同时执行
      PIPE command-sequence; command-sequence; [; command-sequence]

      b. 命令执行的条件化
      PIPE command-sequence1 && command-sequence2
      PIPE command-sequence1 || command-sequence2

      c. 命令执行的管道化
      PIPE pipeline-segment | pipeline-segment [|...]

      d. Subshell excution
      PIPE ( command-sequence [ separator command-sequence]...)

      e. Background excution
      PIPE command-sequence [ separator command-sequence]... &

** DWR脚本编译:

      BACK01$:[PATCH.DWRTOOL.DWR.DWR_JH]
      $ SET DEF BACK01$:[PATCH.DWRTOOL]
      @[.TOOLSET]DWR_SETENV JH
      DWR$LOAD
      perl dwrtool.pl -c DEBUG.CONF -l JH -n JH
      DWR$EXTRACT
      DWR$QUIT

      perl private_tools\ATP\AIR_FEEDER_BECMD.PL AST591 "perl TOL$DCL:BIZTOOL.PL -m TR0000400023590000" " : [TRYYYYYYYYYYYYYYYY0000400023590000]" search

** 常用主机IP地址:
      dev03 : 172.23.1.101

** 开发主机上代码作QA检查
      @dtools:check_qa xxxx.c SIR [ADD|REPLACE|...]

** 竟价模拟器:
      http://svn.tc.com/TOOLDoc/TestTools/MTPEMulator/MTPEmulator文档.docx
      U3$:[RXCHEN.DEV.SRC]TEST_SIM.C;59
** trunc
      set def data02$:[000000]
      set file /trunc [...]*.*
** Openvms条件编译:
      comp xxxx /define=TEST
      is same as:
      #define TEST 1

      /DEFINE="funct(a)=a+sin(a)"
      This definition produces the same results as the following definition:
      #define funct(a) a+sin(a)

      gcc条件编译:
      gcc xxxx.c -D TRUE
      is same as use this macro in xxxx.c

      #define TRUE 1

      mcr NGTS_SYS$:[TOFF55.TOOLS.EXE_I64]XDATA.EXE AGP101$:[TOFF55.DATA.FILES]FPSERI20106.RUJ  toff$fdl:RMSERI2T.FED toff$work_Dir:hjiang_ser2.csv
** 后台环境主机确认
   SEA USER_FTOP_MSG_FILE "MASTER HRRM"
   显示:
   [INFORMATION] HRRM on Host(XXXX) is the Master HRRM 

* Atp Frame Test
** upgrade to latest atp version
   @BACK01$:[TOFF15.DATA.POST_BACKUP]POST_RESTORE_CNTRL.COM
   BACK01$:[TOFF27.DATA.POST_BACKUP.POST_BACKUP_A050000_AST_20070312]
** front end order sending (iterate)
   file:/d/Org/Atp/FrameTest/allatp.sql
** set 100 test

* windows upan recover
** Win+R(administrator) --> diskpart --> list disk
   select disk x(Enter) --> clean
   MyComputer --> Manager --> Disk Manager --> rebuild your disk 
* Core PlatFrom Auto Run:
** SVN
   http://svn.tc.com/MultiGroupTask///trunk/

* ToDoList
** <2018-07-23 一>
   1. learn more about emacs magit
   2. config emacs as a mail client
   3. body training
   4. 10min meditation
   5. find some good videos of emacs
